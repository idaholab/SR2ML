# Copyright 2020, Battelle Energy Alliance, LLC
# ALL RIGHTS RESERVED
"""
Created on May 28, 2021

@author: wangc, mandd
"""
#External Modules------------------------------------------------------------------------------------
import abc
import numpy as np
import copy
#External Modules End--------------------------------------------------------------------------------

#Internal Modules------------------------------------------------------------------------------------
from ravenframework.utils import mathUtils as utils
from ravenframework.utils import InputData, InputTypes
#Internal Modules End--------------------------------------------------------------------------------

class ModelBase(object):
  """
    Base class for SR2ML models
  """

  @classmethod
  def getInputSpecification(cls):
    """
      Collects input specifications for this class.
      @ In, None
      @ Out, inputSpecs, InputData, specs
    """
    inputSpecs = InputData.parameterInputFactory(cls.__name__)
    inputSpecs.addParam('type', param_type=InputTypes.StringType, descr='The model object identifier')
    return inputSpecs

  def __init__(self):
    """
      Constructor
      @ In, None
      @ Out, None
    """
    self.type = self.__class__.__name__
    self.name = self.__class__.__name__
    # not used yet
    # True indicates model could accept time series input data, and returns
    # time-dependent reliability data (Default True)
    self._dynamicHandling    = False
    # dictionary: keys all required input parameters, and values either user provided values or
    # variables determined by raven
    self._variableDict = {}
    # instance of model
    self._model = None
    # class of model
    self._modelClass = None
    self.workingDir = None

  def handleInput(self, xmlNode):
    """
      Function to read the portion of the xml input that belongs to this specialized class
      and initialize some stuff based on the inputs got
      @ In, xmlNode, xml.etree.ElementTree.Element, Xml element node
      @ Out, None
    """
    paramInput = self.getInputSpecification()()
    paramInput.parseNode(xmlNode)
    self._handleInput(paramInput)

  @abc.abstractmethod
  def _handleInput(self, paramInput):
    """
      Function to process the parsed xml input
      @ In, paramInput, InputData.ParameterInput, the parsed xml input
      @ Out, None
    """

  def setWorkingDir(self, workingDir):
    """
      Set the path for working direcotry
      @ In, workingDir, str, the path for working directory
      @ Out, None
    """
    self.workingDir = workingDir

  def initialize(self, inputDict):
    """
      Method to initialize
      @ In, inputDict, dict, dictionary of inputs
      @ Out, None
    """
    needDict = self.getInitParams()
    needDict = self.loadVariables(needDict, inputDict)
    self.setParams(needDict)
    self._checkInputParams(needDict)

  def _checkInputParams(self, needDict):
    """
      Method to check input parameters
      @ In, needDict, dict, dictionary of required parameters
      @ Out, None
    """
    pass

  def isDynamic(self):
    """
      This method is utility function that tells if the reliability model is able to
      treat dynamic data on its own or not
      @ In, None
      @ Out, isDynamic, bool, True if the reliability model is able to treat dynamic data, False otherwise
    """
    return self._dynamicHandling

  def setVariable(self, name, value):
    """
      Set value if a float/int/list is provided in the node text, otherwise treat the provided value as RAVEN variable
      @ In, name, str, the name of variable
      @ In, value, str or float or list, the value of given variable
      @ Out, None
    """
    ret = None
    # multi-entry or single-entry?
    if len(value) == 1:
      if not utils.isAFloatOrInt(value[0]):
        ret = value[0]
        ## add it to _variableDict, so the code can aware of this variable
        if name in self._variableDict.keys():
          raise KeyError('Duplicate variable: "{}" is found! Please check your input file.'.format(name))
        self._variableDict[name] = ret
      else: ## string is provided, so treat it as RAVEN variables
        ret = np.atleast_1d(value)
    else:
      # should be floats; InputData assures the entries are the same type already
      if not utils.isAFloatOrInt(value[0]):
        raise IOError('Multiple non-number entries are found, but require either a single variable name or multiple float entries: {}'.format(value))
      ret = np.asarray(value)
    ## assign self variables, so that both RAVEN and SR2ML can retrieve this variable
    setattr(self, name, ret)

  def loadVariables(self, need, inputDict):
    """
      Load the values of variables that are generated by RAVEN
      @ In, need, dict, the dict of parameters
      @ In, inputDict, dict, the dict of parameters that is provided from other sources
      @ Out, need, dict, the dict of parameters updated with variables
    """
    # load variable values from variables as needed
    for key, val in need.items():
      if utils.isAString(val):
        value = inputDict.get(val, None)
        if value is None:
          raise KeyError('Looking for variable "{}" to fill "{}" but not found among variables!'.format(val, key))
        need[key] = np.atleast_1d(value)
    return need

  def getInitParams(self):
    """
      Get the initial parameters
      @ In, None
      @ Out, self._variableList, dict, list of variables
    """
    ## copy is required, since we are using the initial setup of self._variableDict
    ## to tell the system which variables to update on the fly.
    return copy.copy(self._variableDict)

  def setParams(self, paramDict):
    """
      Set the parameters from a given dictionary.
      @ In, paramDict, dict, settings
      @ Out, None
    """
    for key, val in paramDict.items():
      if key in self.__dict__.keys():
        setattr(self, key, val)
      else:
        raise KeyError('Variable "{}" is not defined in class "{}"!'.format(key, self.name))

  @abc.abstractmethod
  def run(self):
    """
      Method to calculate reliability related quantities
      @ In, None
      @ Out, None
    """
